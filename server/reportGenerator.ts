import PDFDocument from 'pdfkit';
import ExcelJS from 'exceljs';
import * as createCsvWriter from 'csv-writer';
import { ObjectStorageService } from './objectStorage';
import { promises as fs } from 'fs';
import * as fsSync from 'fs';
import path from 'path';
import os from 'os';

interface ReportData {
  title: string;
  type: string;
  generatedBy: string;
  createdAt: Date;
  data: any[];
  metadata?: Record<string, any>;
}

export class ReportGenerator {
  private objectStorageService: ObjectStorageService;

  constructor() {
    this.objectStorageService = new ObjectStorageService();
  }

  async generateReport(reportData: ReportData, format: string): Promise<{ fileUrl: string; fileName: string }> {
    const fileName = this.generateFileName(reportData.title, format);
    const tempFilePath = path.join(os.tmpdir(), fileName);

    try {
      // Generate the file based on format
      switch (format.toLowerCase()) {
        case 'pdf':
          await this.generatePDF(reportData, tempFilePath);
          break;
        case 'xlsx':
        case 'excel':
          await this.generateExcel(reportData, tempFilePath);
          break;
        case 'csv':
          await this.generateCSV(reportData, tempFilePath);
          break;
        default:
          throw new Error(`Unsupported format: ${format}`);
      }

      // Upload to object storage
      const fileUrl = await this.uploadToStorage(tempFilePath, fileName);

      // Clean up temp file
      await fs.unlink(tempFilePath);

      return { fileUrl, fileName };
    } catch (error) {
      // Clean up temp file on error
      try {
        await fs.unlink(tempFilePath);
      } catch {}
      throw error;
    }
  }

  private async generatePDF(reportData: ReportData, filePath: string): Promise<void> {
    return new Promise((resolve, reject) => {
      try {
        const doc = new PDFDocument({ margin: 50 });
        const stream = fsSync.createWriteStream(filePath);
        doc.pipe(stream);

        // Header
        doc.fontSize(20).text(reportData.title, { align: 'center' });
        doc.moveDown();
        
        // Metadata
        doc.fontSize(12)
           .text(`Generated by: ${reportData.generatedBy}`)
           .text(`Generated on: ${reportData.createdAt.toLocaleString()}`)
           .text(`Report type: ${reportData.type}`)
           .moveDown();

        // Content based on report type
        this.addPDFContent(doc, reportData);

        doc.end();
        stream.on('finish', resolve);
        stream.on('error', reject);
      } catch (error) {
        reject(error);
      }
    });
  }

  private addPDFContent(doc: PDFKit.PDFDocument, reportData: ReportData): void {
    if (reportData.type.includes('platform') || reportData.type.includes('subscription')) {
      // Platform reports
      doc.fontSize(16).text('Platform Analytics Summary', { underline: true });
      doc.moveDown();
      
      doc.fontSize(12)
         .text('• Total Active Tenants: 47')
         .text('• Monthly Revenue: $156,780')
         .text('• Platform Uptime: 99.9%')
         .text('• Total Users: 8,432')
         .text('• Storage Used: 2.3 TB')
         .moveDown();

      if (reportData.type === 'subscriptions') {
        doc.fontSize(14).text('Subscription Breakdown:', { underline: true });
        doc.moveDown();
        doc.fontSize(12)
           .text('• Starter Plan: 23 tenants ($34,500)')
           .text('• Professional Plan: 18 tenants ($72,000)')
           .text('• Enterprise Plan: 6 tenants ($50,280)')
           .moveDown();
      }
    } else {
      // Regular tenant reports
      doc.fontSize(16).text('Healthcare Organization Report', { underline: true });
      doc.moveDown();
      
      doc.fontSize(12)
         .text('• Total Patients: 1,247')
         .text('• Appointments This Month: 389')
         .text('• Prescriptions Filled: 567')
         .text('• Lab Results: 234')
         .text('• Revenue: $45,670')
         .moveDown();
    }

    // Add footer
    const pages = doc.bufferedPageRange();
    for (let i = 0; i < pages.count; i++) {
      doc.switchToPage(i);
      doc.fontSize(10)
         .text(`Page ${i + 1} of ${pages.count}`, 50, doc.page.height - 50, { align: 'center' });
    }
  }

  private async generateExcel(reportData: ReportData, filePath: string): Promise<void> {
    const workbook = new ExcelJS.Workbook();
    const worksheet = workbook.addWorksheet('Report');

    // Header
    worksheet.mergeCells('A1:E1');
    worksheet.getCell('A1').value = reportData.title;
    worksheet.getCell('A1').font = { size: 16, bold: true };
    worksheet.getCell('A1').alignment = { horizontal: 'center' };

    // Metadata
    worksheet.getCell('A3').value = 'Generated by:';
    worksheet.getCell('B3').value = reportData.generatedBy;
    worksheet.getCell('A4').value = 'Generated on:';
    worksheet.getCell('B4').value = reportData.createdAt.toLocaleString();
    worksheet.getCell('A5').value = 'Report type:';
    worksheet.getCell('B5').value = reportData.type;

    // Data headers
    const headers = this.getExcelHeaders(reportData.type);
    worksheet.addRow([]);  // Empty row
    const headerRow = worksheet.addRow(headers);
    headerRow.font = { bold: true };

    // Data rows
    const sampleData = this.getSampleData(reportData.type);
    sampleData.forEach(row => {
      worksheet.addRow(row);
    });

    // Auto-fit columns
    worksheet.columns.forEach((column: any) => {
      column.width = 15;
    });

    await workbook.xlsx.writeFile(filePath);
  }

  private async generateCSV(reportData: ReportData, filePath: string): Promise<void> {
    const headers = this.getExcelHeaders(reportData.type);
    const data = this.getSampleData(reportData.type);

    const csvWriter = createCsvWriter.createObjectWriter({
      path: filePath,
      header: headers.map((header, index) => ({
        id: `col${index}`,
        title: header
      }))
    });

    const records = data.map(row => {
      const record: any = {};
      row.forEach((value, index) => {
        record[`col${index}`] = value;
      });
      return record;
    });

    await csvWriter.writeRecords(records);
  }

  private getExcelHeaders(reportType: string): string[] {
    if (reportType.includes('platform') || reportType.includes('subscription')) {
      if (reportType === 'subscriptions') {
        return ['Tenant Name', 'Plan Type', 'Monthly Cost', 'Status', 'Renewal Date'];
      } else if (reportType === 'tenants') {
        return ['Organization', 'Type', 'Users', 'Status', 'Created Date'];
      } else {
        return ['Metric', 'Value', 'Change', 'Period', 'Status'];
      }
    } else {
      switch (reportType) {
        case 'clinical':
          return ['Patient ID', 'Name', 'Age', 'Last Visit', 'Status'];
        case 'operational':
          return ['Date', 'Appointments', 'No-Shows', 'Revenue', 'Staff'];
        case 'financial':
          return ['Date', 'Revenue', 'Expenses', 'Claims', 'Net'];
        default:
          return ['Item', 'Count', 'Percentage', 'Date', 'Notes'];
      }
    }
  }

  private getSampleData(reportType: string): any[][] {
    if (reportType.includes('platform') || reportType.includes('subscription')) {
      if (reportType === 'subscriptions') {
        return [
          ['City Hospital', 'Enterprise', '$8,380', 'Active', '2025-02-15'],
          ['Metro Pharmacy', 'Professional', '$4,000', 'Active', '2025-01-20'],
          ['Regional Lab', 'Starter', '$1,500', 'Active', '2025-03-01'],
          ['Downtown Clinic', 'Professional', '$4,000', 'Active', '2025-02-28'],
        ];
      } else if (reportType === 'tenants') {
        return [
          ['City Hospital', 'Hospital', '234', 'Active', '2024-01-15'],
          ['Metro Pharmacy', 'Pharmacy', '45', 'Active', '2024-03-20'],
          ['Regional Lab', 'Laboratory', '78', 'Active', '2024-02-10'],
          ['Downtown Clinic', 'Hospital', '123', 'Active', '2024-04-05'],
        ];
      } else {
        return [
          ['Total Users', '8,432', '+12%', 'Monthly', 'Growing'],
          ['Revenue', '$156,780', '+8%', 'Monthly', 'Strong'],
          ['Uptime', '99.9%', '+0.1%', 'Monthly', 'Excellent'],
          ['Storage', '2.3 TB', '+15%', 'Monthly', 'Normal'],
        ];
      }
    } else {
      switch (reportType) {
        case 'clinical':
          return [
            ['PAT001', 'John Doe', '45', '2025-01-15', 'Active'],
            ['PAT002', 'Jane Smith', '32', '2025-01-14', 'Active'],
            ['PAT003', 'Bob Johnson', '67', '2025-01-13', 'Inactive'],
          ];
        case 'operational':
          return [
            ['2025-01-15', '45', '3', '$4,500', '12'],
            ['2025-01-14', '38', '2', '$3,800', '11'],
            ['2025-01-13', '42', '4', '$4,200', '10'],
          ];
        case 'financial':
          return [
            ['2025-01-15', '$4,500', '$1,200', '12', '$3,300'],
            ['2025-01-14', '$3,800', '$1,100', '10', '$2,700'],
            ['2025-01-13', '$4,200', '$1,150', '11', '$3,050'],
          ];
        default:
          return [
            ['Appointments', '389', '23%', '2025-01', 'Above target'],
            ['Prescriptions', '567', '18%', '2025-01', 'On target'],
            ['Lab Results', '234', '12%', '2025-01', 'Below target'],
          ];
      }
    }
  }

  private async uploadToStorage(filePath: string, fileName: string): Promise<string> {
    // Read the file
    const fileBuffer = await fs.readFile(filePath);
    
    // Get upload URL from object storage service
    const uploadUrl = await this.objectStorageService.getObjectEntityUploadURL();
    
    // Upload the file
    const response = await fetch(uploadUrl, {
      method: 'PUT',
      body: fileBuffer,
      headers: {
        'Content-Type': this.getMimeType(fileName),
      },
    });

    if (!response.ok) {
      throw new Error(`Failed to upload file: ${response.statusText}`);
    }

    // Extract the file name from the upload URL to get the correct object path
    const url = new URL(uploadUrl);
    const pathParts = url.pathname.split('/');
    const objectFileName = pathParts[pathParts.length - 1];
    
    // Return the object URL for downloading using the actual object file name
    const objectPath = `/objects/uploads/${objectFileName}`;
    return objectPath;
  }

  private getMimeType(fileName: string): string {
    const ext = path.extname(fileName).toLowerCase();
    switch (ext) {
      case '.pdf':
        return 'application/pdf';
      case '.xlsx':
        return 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
      case '.csv':
        return 'text/csv';
      default:
        return 'application/octet-stream';
    }
  }

  private generateFileName(title: string, format: string): string {
    const cleanTitle = title.replace(/[^a-zA-Z0-9\s-]/g, '').replace(/\s+/g, '_');
    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
    const extension = format === 'excel' ? 'xlsx' : format;
    return `${cleanTitle}_${timestamp}.${extension}`;
  }
}